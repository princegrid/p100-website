'use client';

import { useState, useEffect } from 'react';
import { useSearchParams, notFound } from 'next/navigation';
import { createClient, createAdminClient, sanitizeInput, validateInput } from '@/lib/supabase-client';
import Navigation from '@/components/ui/Navigation';
import BackgroundWrapper from '@/components/BackgroundWrapper';
import { useToast } from '@/hooks/use-toast';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';

interface Submission {
  id: string;
  username: string;
  killer_id?: string;
  survivor_id?: string;
  screenshot_url: string;
  status: 'pending' | 'approved' | 'rejected';
  rejection_reason?: string;
  submitted_at: string;
}

interface NewCharacterForm {
  name: string;
  id: string;
  image: File | null;
  backgroundImage: File | null;
  headerImage: File | null;
  artistImages: File[];
}

// Rate limiting configuration
const MAX_LOGIN_ATTEMPTS = 5;
const LOCKOUT_DURATION = 15 * 60 * 1000; // 15 minutes

interface LoginAttempts {
  count: number;
  lastAttempt: number;
  isLocked: boolean;
}

export default function AdminPage() {
  const searchParams = useSearchParams();
  const secretKey = searchParams.get('key');
  
  // Check if the correct secret key is provided
  if (secretKey !== process.env.NEXT_PUBLIC_ADMIN_SECRET_KEY) {
    notFound();
  }

  const [submissions, setSubmissions] = useState<Submission[]>([]);
  const [killers, setKillers] = useState<Character[]>([]);
  const [survivors, setSurvivors] = useState<Character[]>([]);
  const [loading, setLoading] = useState(false);
  const [filter, setFilter] = useState<'all' | 'killer' | 'survivor'>('all');
  const [statusFilter, setStatusFilter] = useState<'all' | 'pending' | 'approved' | 'rejected'>('pending');
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [password, setPassword] = useState('');
  const [authLoading, setAuthLoading] = useState(false);
  
  // Rate limiting state
  const [loginAttempts, setLoginAttempts] = useState<LoginAttempts>({
    count: 0,
    lastAttempt: 0,
    isLocked: false
  });
  const [lockoutTimeRemaining, setLockoutTimeRemaining] = useState(0);
  
  // Character creation form states
  const [newKillerForm, setNewKillerForm] = useState<NewCharacterForm>({
    name: '',
    id: '',
    image: null,
    backgroundImage: null,
    headerImage: null,
    artistImages: []
  });
  const [newSurvivorForm, setNewSurvivorForm] = useState<NewCharacterForm>({
    name: '',
    id: '',
    image: null,
    backgroundImage: null,
    headerImage: null,
    artistImages: []
  });  
  const [creatingCharacter, setCreatingCharacter] = useState(false);
  
  // Character management states
  const [allKillers, setAllKillers] = useState<Array<{
    id: string;
    name: string;
    image_url: string;
    background_image_url?: string;
    header_url?: string;
    artist_urls?: string[];
    order?: number;
    created_at: string;
  }>>([]);
  const [allSurvivors, setAllSurvivors] = useState<Array<{
    id: string;
    name: string;
    image_url: string;
    background_image_url?: string;
    artist_urls?: string[];
    legacy_header_urls?: string[];
    order_num?: number;
    created_at: string;
  }>>([]);
  
  const [deletingItem, setDeletingItem] = useState<string | null>(null);
  
  const { toast } = useToast();

  useEffect(() => {
    // Check if already authenticated (stored in sessionStorage)
    const isAuth = sessionStorage.getItem('admin_authenticated') === 'true';
    setIsAuthenticated(isAuth);
    
    // Check for stored login attempts
    const storedAttempts = localStorage.getItem('admin_login_attempts');
    if (storedAttempts) {
      try {
        const attempts: LoginAttempts = JSON.parse(storedAttempts);
        const now = Date.now();
        
        // Check if lockout has expired
        if (attempts.isLocked && (now - attempts.lastAttempt) > LOCKOUT_DURATION) {
          attempts.count = 0;
          attempts.isLocked = false;
          localStorage.setItem('admin_login_attempts', JSON.stringify(attempts));
        }
        
        setLoginAttempts(attempts);
        
        // Set initial countdown if locked
        if (attempts.isLocked) {
          const remaining = Math.ceil((LOCKOUT_DURATION - (now - attempts.lastAttempt)) / 1000);
          setLockoutTimeRemaining(remaining > 0 ? remaining : 0);
        }
      } catch {
        // Invalid JSON, reset
        localStorage.removeItem('admin_login_attempts');
      }
    }
      // Fetch initial data if authenticated
    if (isAuth) {
      fetchSubmissions();
      fetchCharacters();
      fetchAllCharacters();
    }
  }, []);

  // Countdown timer for lockout
  useEffect(() => {
    if (lockoutTimeRemaining > 0) {
      const timer = setTimeout(() => {
        setLockoutTimeRemaining(prev => {
          if (prev <= 1) {
            // Lockout expired
            const updatedAttempts = { count: 0, lastAttempt: 0, isLocked: false };
            setLoginAttempts(updatedAttempts);
            localStorage.setItem('admin_login_attempts', JSON.stringify(updatedAttempts));
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
      
      return () => clearTimeout(timer);
    }
  }, [lockoutTimeRemaining]);
  const fetchCharacters = async () => {
    try {
      const supabase = createAdminClient();
      
      const [killersResponse, survivorsResponse] = await Promise.all([
        supabase
          .from('killers')
          .select('id, name, image_url')
          .order('name', { ascending: true }),
        supabase
          .from('survivors')
          .select('id, name, image_url')
          .order('name', { ascending: true })
      ]);

      if (killersResponse.data) {
        setKillers(killersResponse.data.map(killer => ({
          id: killer.id,
          name: killer.name,
          imageUrl: killer.image_url
        })));
      }

      if (survivorsResponse.data) {
        setSurvivors(survivorsResponse.data.map(survivor => ({
          id: survivor.id,
          name: survivor.name,
          imageUrl: survivor.image_url
        })));
      }
    } catch (error) {
      console.error('Error fetching characters:', error);
    }
  };
  const fetchAllCharacters = async () => {
    try {
      const supabase = createAdminClient();
      
      const [killersResponse, survivorsResponse] = await Promise.all([
        supabase
          .from('killers')
          .select('*')
          .order('name', { ascending: true }),
        supabase
          .from('survivors')
          .select('*')
          .order('name', { ascending: true })
      ]);

      if (killersResponse.data) {
        setAllKillers(killersResponse.data);
      }

      if (survivorsResponse.data) {
        setAllSurvivors(survivorsResponse.data);
      }
    } catch (error) {
      console.error('Error fetching all characters:', error);
    }
  };

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (loginAttempts.isLocked) {
      toast({
        title: "Account Locked",
        description: `Too many failed attempts. Please wait ${Math.ceil(lockoutTimeRemaining / 60)} minutes before trying again.`,
        variant: "destructive",
      });
      return;
    }
    
    setAuthLoading(true);
    
    try {
      const adminPassword = process.env.NEXT_PUBLIC_ADMIN_PASSWORD;
      
      if (password === adminPassword) {
        const resetAttempts = { count: 0, lastAttempt: 0, isLocked: false };
        setLoginAttempts(resetAttempts);
        localStorage.setItem('admin_login_attempts', JSON.stringify(resetAttempts));
        
        setIsAuthenticated(true);
        sessionStorage.setItem('admin_authenticated', 'true');
        setPassword('');
        await fetchSubmissions();
        await fetchCharacters();
        await fetchAllCharacters();
        toast({
          title: "Login Successful",
          description: "Welcome to the admin dashboard.",
        });
      } else {
        const now = Date.now();
        const newCount = loginAttempts.count + 1;
        const isLocked = newCount >= MAX_LOGIN_ATTEMPTS;
        
        const updatedAttempts: LoginAttempts = {
          count: newCount,
          lastAttempt: now,
          isLocked
        };
        
        setLoginAttempts(updatedAttempts);
        localStorage.setItem('admin_login_attempts', JSON.stringify(updatedAttempts));
        
        if (isLocked) {
          setLockoutTimeRemaining(LOCKOUT_DURATION / 1000);
          toast({
            title: "Account Locked",
            description: `Too many failed attempts. Account locked for 15 minutes.`,
            variant: "destructive",
          });
        } else {
          const remainingAttempts = MAX_LOGIN_ATTEMPTS - newCount;
          toast({
            title: "Login Failed",
            description: `Invalid password. ${remainingAttempts} attempts remaining before lockout.`,
            variant: "destructive",
          });
        }
      }
    } catch (error: any) {
      console.error('Login error:', error);
      toast({
        title: "Login Error",
        description: "An error occurred while logging in. Please try again.",
        variant: "destructive",
      });
    } finally {
      setAuthLoading(false);
    }
  };

  const handleLogout = () => {
    setIsAuthenticated(false);
    sessionStorage.removeItem('admin_authenticated');
    setSubmissions([]);
    setAllKillers([]);
    setAllSurvivors([]);
  };

  // Upload image to Supabase storage and return the public URL  const uploadImageToStorage = async (file: File, bucket: string, path: string): Promise<string> => {
    const supabase = createAdminClient();
    
    console.log(`[ADMIN DEBUG] Starting image upload to bucket: ${bucket}, path: ${path}`);
    
    const { data, error } = await supabase.storage
      .from(bucket)
      .upload(path, file, {
        cacheControl: '3600',
        upsert: true // Allow overwriting files
      });

    if (error) {
      console.error('[ADMIN DEBUG] Storage upload error:', error);
      throw new Error(`Failed to upload image: ${error.message}`);
    }

    console.log('[ADMIN DEBUG] Upload successful:', data);

    // Get the public URL
    const { data: { publicUrl } } = supabase.storage
      .from(bucket)
      .getPublicUrl(path);

    console.log('[ADMIN DEBUG] Public URL:', publicUrl);

    return publicUrl;
  };

  // Delete character
  const deleteCharacter = async (characterId: string, characterType: 'killer' | 'survivor') => {
    if (!confirm(`Are you sure you want to delete this ${characterType}? This will also delete all associated P100 players and submissions. This action cannot be undone.`)) {
      return;
    }    setDeletingItem(characterId);
    try {
      const supabase = createAdminClient();
      
      // Delete associated records first
      await Promise.all([
        supabase.from('p100_players').delete().eq(`${characterType}_id`, characterId),
        supabase.from('p100_submissions').delete().eq(`${characterType}_id`, characterId)
      ]);

      // Delete character
      const { error } = await supabase
        .from(`${characterType}s`)
        .delete()
        .eq('id', characterId);

      if (error) {
        throw new Error(`Failed to delete ${characterType}: ${error.message}`);
      }

      toast({
        title: "Success",
        description: `${characterType} has been deleted successfully.`,
      });

      await fetchAllCharacters();
      await fetchCharacters();

    } catch (error: any) {
      console.error(`Error deleting ${characterType}:`, error);
      toast({
        title: "Error",
        description: error.message || `Failed to delete ${characterType}. Please try again.`,
        variant: "destructive",
      });
    } finally {
      setDeletingItem(null);
    }
  };

  // Create new killer
  const createNewKiller = async () => {
    if (!newKillerForm.name || !newKillerForm.id || !newKillerForm.image) {
      toast({
        title: "Validation Error",
        description: "Please fill in all required fields (name, ID, and image).",
        variant: "destructive",
      });
      return;    }

    setCreatingCharacter(true);
    try {
      const supabase = createAdminClient();

      // Check if killer ID already exists
      const { data: existingKiller } = await supabase
        .from('killers')
        .select('id')
        .eq('id', newKillerForm.id)
        .single();

      if (existingKiller) {
        throw new Error('A killer with this ID already exists');
      }

      // Upload main image
      const imageFileName = `${newKillerForm.id}.png`;
      const imageUrl = await uploadImageToStorage(
        newKillerForm.image,
        'killerimages',
        imageFileName
      );

      // Upload optional images
      let backgroundImageUrl = null;
      if (newKillerForm.backgroundImage) {
        const backgroundFileName = `${newKillerForm.id}background.png`;
        backgroundImageUrl = await uploadImageToStorage(
          newKillerForm.backgroundImage,
          'backgrounds',
          backgroundFileName
        );
      }

      let headerImageUrl = null;
      if (newKillerForm.headerImage) {
        const headerFileName = `${newKillerForm.id}header.png`;
        headerImageUrl = await uploadImageToStorage(
          newKillerForm.headerImage,
          'headers',
          headerFileName
        );
      }

      let artistUrls: string[] = [];
      if (newKillerForm.artistImages.length > 0) {
        for (let i = 0; i < newKillerForm.artistImages.length; i++) {
          const artistFileName = `${newKillerForm.id}artist${i + 1}.png`;
          const artistUrl = await uploadImageToStorage(
            newKillerForm.artistImages[i],
            'artist-images',
            artistFileName
          );
          artistUrls.push(artistUrl);
        }
      }

      // Get next order number
      const { data: lastKiller } = await supabase
        .from('killers')
        .select('order')
        .order('order', { ascending: false })
        .limit(1)
        .single();

      const nextOrder = (lastKiller?.order || 0) + 1;

      // Insert killer into database
      const { error } = await supabase
        .from('killers')
        .insert([{
          id: newKillerForm.id,
          name: newKillerForm.name,
          image_url: imageUrl,
          background_image_url: backgroundImageUrl,
          header_url: headerImageUrl,
          artist_urls: artistUrls.length > 0 ? artistUrls : null,
          order: nextOrder
        }]);

      if (error) {
        throw new Error(`Database error during killer creation: ${error.message}`);
      }

      toast({
        title: "Success",
        description: `Killer "${newKillerForm.name}" has been created successfully!`,
      });

      // Reset form
      setNewKillerForm({
        name: '',
        id: '',
        image: null,
        backgroundImage: null,
        headerImage: null,
        artistImages: []
      });

      await fetchCharacters();
      await fetchAllCharacters();

    } catch (error: any) {
      console.error('Error creating killer:', error);
      toast({
        title: "Error",
        description: error.message || "Failed to create killer. Please try again.",
        variant: "destructive",
      });
    } finally {
      setCreatingCharacter(false);
    }
  };

  // Create new survivor
  const createNewSurvivor = async () => {
    if (!newSurvivorForm.name || !newSurvivorForm.id || !newSurvivorForm.image) {
      toast({
        title: "Validation Error",
        description: "Please fill in all required fields (name, ID, and image).",
        variant: "destructive",
      });
      return;
    }    setCreatingCharacter(true);
    try {
      const supabase = createAdminClient();

      // Check if survivor ID already exists
      const { data: existingSurvivor } = await supabase
        .from('survivors')
        .select('id')
        .eq('id', newSurvivorForm.id)
        .single();

      if (existingSurvivor) {
        throw new Error('A survivor with this ID already exists');
      }

      // Upload main image
      const imageFileName = `${newSurvivorForm.id}.png`;
      const imageUrl = await uploadImageToStorage(
        newSurvivorForm.image,
        'survivors',
        imageFileName
      );

      // Upload optional images
      let backgroundImageUrl = null;
      if (newSurvivorForm.backgroundImage) {
        const backgroundFileName = `${newSurvivorForm.id}background.png`;
        backgroundImageUrl = await uploadImageToStorage(
          newSurvivorForm.backgroundImage,
          'backgrounds',
          backgroundFileName
        );
      }

      let artistUrls: string[] = [];
      if (newSurvivorForm.artistImages.length > 0) {
        for (let i = 0; i < newSurvivorForm.artistImages.length; i++) {
          const artistFileName = `${newSurvivorForm.id}artist${i + 1}.png`;
          const artistUrl = await uploadImageToStorage(
            newSurvivorForm.artistImages[i],
            'artist-images',
            artistFileName
          );
          artistUrls.push(artistUrl);
        }
      }

      // Get next order number
      const { data: lastSurvivor } = await supabase
        .from('survivors')
        .select('order_num')
        .order('order_num', { ascending: false })
        .limit(1)
        .single();

      const nextOrder = (lastSurvivor?.order_num || 0) + 1;

      // Insert survivor into database
      const { error } = await supabase
        .from('survivors')
        .insert([{
          id: newSurvivorForm.id,
          name: newSurvivorForm.name,
          image_url: imageUrl,
          background_image_url: backgroundImageUrl,
          artist_urls: artistUrls.length > 0 ? artistUrls : null,
          order_num: nextOrder
        }]);

      if (error) {
        throw new Error(`Database error during survivor creation: ${error.message}`);
      }

      toast({
        title: "Success",
        description: `Survivor "${newSurvivorForm.name}" has been created successfully!`,
      });

      // Reset form
      setNewSurvivorForm({
        name: '',
        id: '',
        image: null,
        backgroundImage: null,
        headerImage: null,
        artistImages: []
      });

      await fetchCharacters();
      await fetchAllCharacters();

    } catch (error: any) {
      console.error('Error creating survivor:', error);
      toast({
        title: "Error",
        description: error.message || "Failed to create survivor. Please try again.",
        variant: "destructive",
      });
    } finally {
      setCreatingCharacter(false);
    }
  };

  const fetchSubmissions = async () => {
    setLoading(true);
    try {
      const supabase = createClient();
      const { data, error } = await supabase
        .from('p100_submissions')
        .select('id, username, killer_id, survivor_id, screenshot_url, status, rejection_reason, submitted_at')
        .order('submitted_at', { ascending: false });

      if (error) throw new Error('Failed to fetch submissions: ' + error.message);
      setSubmissions(data || []);
    } catch (error) {
      console.error('Error fetching submissions:', error);
      toast({
        title: "Error",
        description: "Failed to fetch submissions. Please try again.",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const updateSubmissionStatus = async (
    id: string, 
    status: 'approved' | 'rejected', 
    rejectionReason?: string
  ) => {
    try {
      if (!id || typeof id !== 'string') {
        throw new Error('Invalid submission ID');
      }
      
      if (!['approved', 'rejected'].includes(status)) {
        throw new Error('Invalid status');
      }      const sanitizedReason = rejectionReason ? sanitizeInput(rejectionReason) : null;
      
      const supabase = createAdminClient();
      
      const submission = submissions.find(s => s.id === id);
      const characterName = getCharacterName(submission!);
      
      const { error } = await supabase
        .from('p100_submissions')
        .update({
          status,
          rejection_reason: sanitizedReason,
          reviewed_at: new Date().toISOString(),
          reviewed_by: 'admin'
        })
        .eq('id', id);

      if (error) throw new Error('Failed to update submission: ' + error.message);

      // If approved, add to p100_players table
      if (status === 'approved') {
        const submission = submissions.find(s => s.id === id);
        if (submission) {
          const sanitizedUsername = sanitizeInput(submission.username);
          
          if (!validateInput.username(sanitizedUsername)) {
            throw new Error('Invalid username in submission');
          }

          // Check if player already exists for this character
          const existingPlayerQuery = submission.killer_id 
            ? supabase.from('p100_players').select('id').eq('killer_id', submission.killer_id).eq('username', sanitizedUsername)
            : supabase.from('p100_players').select('id').eq('survivor_id', submission.survivor_id).eq('username', sanitizedUsername);

          const { data: existingPlayer, error: checkError } = await existingPlayerQuery;
          
          if (checkError) {
            console.error('Error checking existing player:', checkError);
            throw new Error('Failed to check existing player: ' + checkError.message);
          }

          // Only insert if player doesn't already exist
          if (!existingPlayer || existingPlayer.length === 0) {
            const playerData = {
              username: sanitizedUsername,
              killer_id: submission.killer_id,
              survivor_id: submission.survivor_id
            };

            const { error: playerError } = await supabase
              .from('p100_players')
              .insert([playerData]);
              
            if (playerError) {
              console.error('Error adding to p100_players:', playerError);
              throw new Error('Failed to add player: ' + playerError.message);
            }
          }
        }
        
        toast({
          title: "P100 Approved! ðŸŽ‰",
          description: `${submission?.username}'s P100 ${characterName} has been approved and added to the list.`,
        });
      } else {
        toast({
          title: "P100 Rejected",
          description: `${submission?.username}'s P100 ${characterName} submission has been rejected.${rejectionReason ? ` Reason: ${rejectionReason}` : ''}`,
          variant: "destructive",
        });
      }

      await fetchSubmissions();
    } catch (error) {
      console.error('Error updating submission:', error);
      toast({
        title: "Error",
        description: `Failed to ${status === 'approved' ? 'approve' : 'reject'} submission. Please try again.`,
        variant: "destructive",
      });
    }
  };

  const getCharacterName = (submission: Submission) => {
    if (submission.killer_id) {
      return killers.find(k => k.id === submission.killer_id)?.name || 'Unknown Killer';
    }
    if (submission.survivor_id) {
      return survivors.find(s => s.id === submission.survivor_id)?.name || 'Unknown Survivor';
    }
    return 'Unknown Character';
  };

  const filteredSubmissions = submissions.filter(submission => {
    const typeMatch = filter === 'all' || 
      (filter === 'killer' && submission.killer_id) ||
      (filter === 'survivor' && submission.survivor_id);
    
    const statusMatch = statusFilter === 'all' || submission.status === statusFilter;
    
    return typeMatch && statusMatch;
  });

  const formatTime = (seconds: number) => {
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  };

  if (!isAuthenticated) {
    return (
      <BackgroundWrapper backgroundUrl="/admin.png">
        <Navigation />
        <main className="container mx-auto px-4 py-8">
          <div className="max-w-md mx-auto">
            <h1 className="text-3xl font-mono mb-8 text-center">Admin Login</h1>
            
            {loginAttempts.isLocked && (
              <div className="mb-6 p-4 bg-red-900/50 border border-red-600 rounded text-center">
                <p className="text-red-300 mb-2">Account temporarily locked due to too many failed attempts.</p>
                <p className="text-white font-mono text-lg">
                  Time remaining: {formatTime(lockoutTimeRemaining)}
                </p>
              </div>
            )}
            
            <form onSubmit={handleLogin} className="space-y-4">
              <div>
                <label htmlFor="password" className="block text-sm font-medium mb-1">
                  Admin Password
                </label>
                <input
                  type="password"
                  id="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  required
                  disabled={loginAttempts.isLocked}
                  className="w-full p-2 border border-red-600 rounded bg-black text-white placeholder-gray-400 focus:border-red-400 focus:outline-none transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                  placeholder="Enter admin password"
                />
              </div>
              
              <button
                type="submit"
                disabled={authLoading || loginAttempts.isLocked}
                className="w-full px-4 py-2 bg-black border border-red-600 text-white rounded hover:bg-red-900 hover:border-red-400 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
              >
                {authLoading ? 'Logging in...' : loginAttempts.isLocked ? 'Account Locked' : 'Login'}
              </button>
              
              {loginAttempts.count > 0 && !loginAttempts.isLocked && (
                <p className="text-center text-yellow-400 text-sm">
                  {MAX_LOGIN_ATTEMPTS - loginAttempts.count} attempts remaining
                </p>
              )}
            </form>
          </div>
        </main>
      </BackgroundWrapper>
    );
  }

  return (
    <BackgroundWrapper backgroundUrl="/admin.png">
      <Navigation />
      <main className="container mx-auto px-4 py-8">
        <div className="max-w-7xl mx-auto">
          <div className="flex justify-between items-center mb-8">
            <h1 className="text-3xl font-mono">Admin Dashboard</h1>
            <button
              onClick={handleLogout}
              className="px-4 py-2 bg-black border border-red-600 text-white rounded hover:bg-red-900 hover:border-red-400 transition-all"
            >
              Logout
            </button>
          </div>
          
          <Tabs defaultValue="submissions" className="w-full">
            <TabsList className="grid w-full grid-cols-3 mb-8">
              <TabsTrigger value="submissions">P100 Submissions</TabsTrigger>
              <TabsTrigger value="characters">Add Characters</TabsTrigger>
              <TabsTrigger value="manage">Manage Content</TabsTrigger>
            </TabsList>
            
            <TabsContent value="submissions" className="space-y-6">
              <div className="mb-6 flex gap-4">
                <select 
                  value={filter} 
                  onChange={(e) => setFilter(e.target.value as any)}
                  className="p-2 border border-red-600 rounded bg-black text-white focus:border-red-400 focus:outline-none transition-colors"
                >
                  <option value="all">All Characters</option>
                  <option value="killer">Killers Only</option>
                  <option value="survivor">Survivors Only</option>
                </select>
                
                <select 
                  value={statusFilter} 
                  onChange={(e) => setStatusFilter(e.target.value as any)}
                  className="p-2 border border-red-600 rounded bg-black text-white focus:border-red-400 focus:outline-none transition-colors"
                >
                  <option value="all">All Status</option>
                  <option value="pending">Pending</option>
                  <option value="approved">Approved</option>
                  <option value="rejected">Rejected</option>
                </select>
              </div>

              {loading ? (
                <div className="text-center">Loading submissions...</div>
              ) : (
                <div className="grid gap-4">
                  {filteredSubmissions.map((submission) => (
                    <div key={submission.id} className="border rounded p-4 bg-background/50">
                      <div className="flex justify-between items-start mb-4">
                        <div>
                          <h3 className="font-bold">{submission.username}</h3>
                          <p>{getCharacterName(submission)}</p>
                          <p className="text-sm text-gray-500">
                            {new Date(submission.submitted_at).toLocaleDateString()}
                          </p>
                          <span className={`text-xs px-2 py-1 rounded ${
                            submission.status === 'pending' ? 'bg-yellow-200 text-yellow-800' :
                            submission.status === 'approved' ? 'bg-green-200 text-green-800' :
                            'bg-red-200 text-red-800'
                          }`}>
                            {submission.status}
                          </span>
                        </div>
                        
                        <div className="flex-shrink-0">
                          <img 
                            src={submission.screenshot_url} 
                            alt="P100 Screenshot"
                            className="w-32 h-32 object-cover rounded cursor-pointer"
                            onClick={() => window.open(submission.screenshot_url, '_blank')}
                          />
                        </div>
                      </div>

                      {submission.status === 'pending' && (
                        <div className="flex gap-2">
                          <button
                            onClick={() => updateSubmissionStatus(submission.id, 'approved')}
                            className="px-4 py-2 bg-black border border-green-500 text-green-400 rounded hover:bg-green-900/20 hover:border-green-400 transition-all"
                          >
                            Approve
                          </button>
                          <button
                            onClick={() => {
                              const reason = prompt('Rejection reason (optional):');
                              if (reason !== null) {
                                updateSubmissionStatus(submission.id, 'rejected', reason || undefined);
                              }
                            }}
                            className="px-4 py-2 bg-black border border-red-600 text-red-400 rounded hover:bg-red-900 hover:border-red-400 transition-all"
                          >
                            Reject
                          </button>
                        </div>
                      )}

                      {submission.rejection_reason && (
                        <div className="mt-2 p-2 bg-red-100 text-red-700 rounded text-sm">
                          Rejection reason: {submission.rejection_reason}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}

              {!loading && filteredSubmissions.length === 0 && (
                <div className="text-center text-gray-500 mt-8">
                  No submissions found.
                </div>
              )}
            </TabsContent>
            
            <TabsContent value="characters" className="space-y-6">
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                {/* Add New Killer */}
                <div className="space-y-4">
                  <h2 className="text-2xl font-mono mb-4">Add New Killer</h2>
                  
                  <div className="space-y-4">
                    <div>
                      <Label htmlFor="killer-name">Killer Name</Label>
                      <Input
                        id="killer-name"
                        type="text"
                        placeholder="e.g., The Trapper"
                        value={newKillerForm.name}
                        onChange={(e) => setNewKillerForm(prev => ({ ...prev, name: e.target.value }))}
                        className="bg-black border-red-600 text-white placeholder-gray-400"
                      />
                    </div>
                    
                    <div>
                      <Label htmlFor="killer-id">Killer ID (URL slug)</Label>
                      <Input
                        id="killer-id"
                        type="text"
                        placeholder="e.g., trapper (lowercase, no spaces)"
                        value={newKillerForm.id}
                        onChange={(e) => setNewKillerForm(prev => ({ ...prev, id: e.target.value.toLowerCase().replace(/\s+/g, '') }))}
                        className="bg-black border-red-600 text-white placeholder-gray-400"
                      />
                    </div>
                    
                    <div>
                      <Label htmlFor="killer-image">Killer Image *</Label>
                      <Input
                        id="killer-image"
                        type="file"
                        accept="image/*"
                        onChange={(e) => setNewKillerForm(prev => ({ ...prev, image: e.target.files?.[0] || null }))}
                        className="bg-black border-red-600 text-white"
                      />
                    </div>
                    
                    <div>
                      <Label htmlFor="killer-bg">Background Image (optional)</Label>
                      <Input
                        id="killer-bg"
                        type="file"
                        accept="image/*"
                        onChange={(e) => setNewKillerForm(prev => ({ ...prev, backgroundImage: e.target.files?.[0] || null }))}
                        className="bg-black border-red-600 text-white"
                      />
                    </div>
                    
                    <div>
                      <Label htmlFor="killer-header">Header Image (optional)</Label>
                      <Input
                        id="killer-header"
                        type="file"
                        accept="image/*"
                        onChange={(e) => setNewKillerForm(prev => ({ ...prev, headerImage: e.target.files?.[0] || null }))}
                        className="bg-black border-red-600 text-white"
                      />
                    </div>
                    
                    <div>
                      <Label htmlFor="killer-artist">Artist Images (optional, multiple)</Label>
                      <Input
                        id="killer-artist"
                        type="file"
                        accept="image/*"
                        multiple
                        onChange={(e) => setNewKillerForm(prev => ({ ...prev, artistImages: Array.from(e.target.files || []) }))}
                        className="bg-black border-red-600 text-white"
                      />
                      <p className="text-sm text-gray-400 mt-1">
                        These images will be stored in the artist_urls column and displayed as artwork
                      </p>
                    </div>
                    
                    <Button
                      onClick={createNewKiller}
                      disabled={creatingCharacter}
                      className="w-full bg-black border border-red-600 text-white hover:bg-red-900 hover:border-red-400"
                    >
                      {creatingCharacter ? 'Creating...' : 'Create Killer'}
                    </Button>
                  </div>
                </div>
                
                {/* Add New Survivor */}
                <div className="space-y-4">
                  <h2 className="text-2xl font-mono mb-4">Add New Survivor</h2>
                  
                  <div className="space-y-4">
                    <div>
                      <Label htmlFor="survivor-name">Survivor Name</Label>
                      <Input
                        id="survivor-name"
                        type="text"
                        placeholder="e.g., Dwight Fairfield"
                        value={newSurvivorForm.name}
                        onChange={(e) => setNewSurvivorForm(prev => ({ ...prev, name: e.target.value }))}
                        className="bg-black border-red-600 text-white placeholder-gray-400"
                      />
                    </div>
                    
                    <div>
                      <Label htmlFor="survivor-id">Survivor ID (URL slug)</Label>
                      <Input
                        id="survivor-id"
                        type="text"
                        placeholder="e.g., dwight (lowercase, no spaces)"
                        value={newSurvivorForm.id}
                        onChange={(e) => setNewSurvivorForm(prev => ({ ...prev, id: e.target.value.toLowerCase().replace(/\s+/g, '') }))}
                        className="bg-black border-red-600 text-white placeholder-gray-400"
                      />
                    </div>
                    
                    <div>
                      <Label htmlFor="survivor-image">Survivor Image *</Label>
                      <Input
                        id="survivor-image"
                        type="file"
                        accept="image/*"
                        onChange={(e) => setNewSurvivorForm(prev => ({ ...prev, image: e.target.files?.[0] || null }))}
                        className="bg-black border-red-600 text-white"
                      />
                    </div>
                    
                    <div>
                      <Label htmlFor="survivor-bg">Background Image (optional)</Label>
                      <Input
                        id="survivor-bg"
                        type="file"
                        accept="image/*"
                        onChange={(e) => setNewSurvivorForm(prev => ({ ...prev, backgroundImage: e.target.files?.[0] || null }))}
                        className="bg-black border-red-600 text-white"
                      />
                    </div>
                    
                    <div>
                      <Label htmlFor="survivor-artist">Artist Images (optional, multiple)</Label>
                      <Input
                        id="survivor-artist"
                        type="file"
                        accept="image/*"
                        multiple
                        onChange={(e) => setNewSurvivorForm(prev => ({ ...prev, artistImages: Array.from(e.target.files || []) }))}
                        className="bg-black border-red-600 text-white"
                      />
                      <p className="text-sm text-gray-400 mt-1">
                        These images will be stored in the artist_urls column and displayed as artwork
                      </p>
                    </div>
                    
                    <Button
                      onClick={createNewSurvivor}
                      disabled={creatingCharacter}
                      className="w-full bg-black border border-red-600 text-white hover:bg-red-900 hover:border-red-400"
                    >
                      {creatingCharacter ? 'Creating...' : 'Create Survivor'}
                    </Button>
                  </div>
                </div>
              </div>
              
              <div className="text-center text-gray-400 text-sm mt-8">
                <p>* Required fields</p>
                <p>Images will be automatically resized and optimized</p>
                <p>Artist images are now stored directly in the character's artist_urls column</p>
              </div>
            </TabsContent>

            <TabsContent value="manage" className="space-y-6">
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                {/* Manage Killers */}
                <div className="space-y-4">
                  <h2 className="text-2xl font-mono mb-4">Manage Killers ({allKillers.length})</h2>
                  <div className="max-h-96 overflow-y-auto space-y-2">
                    {allKillers.map((killer) => (
                      <div key={killer.id} className="flex items-center justify-between p-3 border border-red-600 rounded bg-black/20">
                        <div className="flex items-center space-x-3">
                          <img
                            src={killer.image_url}
                            alt={killer.name}
                            className="w-12 h-12 object-cover rounded"
                          />
                          <div>
                            <div className="font-medium">{killer.name}</div>
                            <div className="text-sm text-gray-500">ID: {killer.id}</div>                            <div className="text-xs text-gray-400">
                              Artist URLs: {killer.artist_urls?.length || 0}
                            </div>
                          </div>
                        </div>
                        <Button
                          onClick={() => deleteCharacter(killer.id, 'killer')}
                          disabled={deletingItem === killer.id}
                          variant="destructive"
                          size="sm"
                        >
                          {deletingItem === killer.id ? 'Deleting...' : 'Delete'}
                        </Button>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Manage Survivors */}
                <div className="space-y-4">
                  <h2 className="text-2xl font-mono mb-4">Manage Survivors ({allSurvivors.length})</h2>
                  <div className="max-h-96 overflow-y-auto space-y-2">
                    {allSurvivors.map((survivor) => (
                      <div key={survivor.id} className="flex items-center justify-between p-3 border border-red-600 rounded bg-black/20">
                        <div className="flex items-center space-x-3">
                          <img
                            src={survivor.image_url}
                            alt={survivor.name}
                            className="w-12 h-12 object-cover rounded"
                          />
                          <div>
                            <div className="font-medium">{survivor.name}</div>
                            <div className="text-sm text-gray-500">ID: {survivor.id}</div>                            <div className="text-xs text-gray-400">
                              Artist URLs: {survivor.artist_urls?.length || 0}
                            </div>
                          </div>
                        </div>
                        <Button
                          onClick={() => deleteCharacter(survivor.id, 'survivor')}
                          disabled={deletingItem === survivor.id}
                          variant="destructive"
                          size="sm"
                        >
                          {deletingItem === survivor.id ? 'Deleting...' : 'Delete'}
                        </Button>
                      </div>
                    ))}
                  </div>
                </div>
              </div>

              <div className="text-center text-gray-400 text-sm mt-8">
                <p><strong>Note:</strong> Deleting characters will also remove all associated P100 players and submissions.</p>
                <p>This action cannot be undone.</p>
                <p>Artwork is now managed through the artist_urls column in each character.</p>
              </div>
            </TabsContent>
          </Tabs>
        </div>
      </main>
    </BackgroundWrapper>
  );
}
